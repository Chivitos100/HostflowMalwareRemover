package haizivs.hostflowmalwareremover;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FrameNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LineNumberNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TypeInsnNode;

public class HostflowRemover {

	public ArrayList<String> infectedFiles = new ArrayList<String>();

	public HostflowRemover(Path p, boolean remover) {
		try {
			Files.walk(p).forEach(path -> scanFile(path.toFile()));

			if (!infectedFiles.isEmpty()) {
				System.err.println(Main.prefix + String.format("Found %s plugins with malware.", infectedFiles.size()));
			} else {
				System.out.println(Main.prefix + "No plugins with malware were found!");
			}
			if (remover) {
				File fPath = new File("plugins-clean");
				if (!fPath.exists())
					fPath.mkdir();

				try {
					for (String s : infectedFiles) {
						File f = new File(s);
						runRemover(f, fPath);
					}
				} catch (Throwable e) {
					e.printStackTrace();
				}
			}
			System.out.println(Main.prefix + "Done!");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public void scanFile(File file) {
		if (!file.isDirectory() && file.getName().endsWith(".jar")) {
			try {
				ZipFile zip = new ZipFile(file);
				Enumeration<? extends ZipEntry> entries = zip.entries();

				while (entries.hasMoreElements()) {
					ZipEntry zipEntry = entries.nextElement();
					zipEntry.setCompressedSize(-1);
					if (zipEntry.getName().equals("javassist/PingMessage.class")
							|| zipEntry.getName().equals("javassist/ResponseContainer.class")) {
						infectedFiles.add(file.getAbsolutePath());
						break;
					}
				}
				zip.close();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	public void runRemover(File file, File filePath) throws Throwable {
		ArrayList<String> ignoreOnOutput = new ArrayList<String>();
		ZipFile zip = new ZipFile(file);
		ZipOutputStream out = new ZipOutputStream(
				new FileOutputStream(new File(filePath.getAbsolutePath() + "/" + file.getName())));
		Enumeration<? extends ZipEntry> entries = zip.entries();
		while (entries.hasMoreElements()) {
			ZipEntry zipEntry = entries.nextElement();
			zipEntry.setCompressedSize(-1);
			if (zipEntry.getName().endsWith("module-info.class"))
				continue;
			if (zipEntry.getName().endsWith(".class")) {
				try (InputStream in = zip.getInputStream(zipEntry)) {
					ClassReader cr = new ClassReader(in);
					ClassNode classNode = new ClassNode();
					cr.accept(classNode, 0);

					if (classNode.superName.equals("org/bukkit/plugin/java/JavaPlugin")) {
						for (MethodNode mn : classNode.methods) {
							if (mn.name.equals("onEnable")) {
								List<AbstractInsnNode> remove = new CopyOnWriteArrayList<>();
								for (AbstractInsnNode insn : mn.instructions) {
									if (insn instanceof TypeInsnNode) {
										TypeInsnNode tinsn = (TypeInsnNode) insn;
										if (tinsn.desc.equals(classNode.name + "L10")) {
											ignoreOnOutput.add(classNode.name + "L10.class");
											remove.add(insn);
											remove.add(getNext(insn, 1));
											remove.add(getNext(insn, 2));
											remove.add(getNext(insn, 3));
											remove.add(getNext(insn, 4));
											remove.add(getNext(insn, 5));
											remove.add(getNext(insn, 6));
										}
									}
								}
								Stream.of(mn.instructions.toArray());
								remove.forEach(ainsn -> mn.instructions.remove(ainsn));
							}
						}
					}

					ClassWriter cw = new ClassWriter(1);
					classNode.accept(cw);

					ZipEntry newEntry = new ZipEntry(zipEntry.getName());
					if (!ignoreOnOutput.contains(newEntry.getName()) && !newEntry.getName().startsWith("javassist/")) {
						out.putNextEntry(newEntry);
						writeToFile(out, new ByteArrayInputStream(cw.toByteArray()));
					}
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				if (!zipEntry.getName().equals(".l1") && !zipEntry.getName().startsWith("javassist/")) {
					out.putNextEntry(zipEntry);
					writeToFile(out, zip.getInputStream(zipEntry));
				}
			}
		}
		zip.close();
		out.close();
	}

	private void writeToFile(ZipOutputStream outputStream, InputStream inputStream) throws Throwable {
		byte[] buffer = new byte[4096];
		try {
			while (inputStream.available() > 0) {
				int data = inputStream.read(buffer);
				outputStream.write(buffer, 0, data);
			}
		} finally {
			inputStream.close();
			outputStream.closeEntry();
		}
	}

	public AbstractInsnNode getNext(AbstractInsnNode node, int amount) {
		for (int i = 0; i < amount; i++) {
			node = getNext(node);
		}
		return node;
	}

	public AbstractInsnNode getNext(AbstractInsnNode node) {
		AbstractInsnNode next = node.getNext();
		while (!isInstruction(next)) {
			next = next.getNext();
		}
		return next;
	}

	public boolean isInstruction(AbstractInsnNode node) {
		return !(node instanceof LineNumberNode) && !(node instanceof FrameNode) && !(node instanceof LabelNode);
	}
}
